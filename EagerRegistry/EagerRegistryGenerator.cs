using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using EagerRegistry.SourceFactories;
using EagerRegistry.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EagerRegistry;

internal record EagerRegistryCandidate(
	string ServiceTypeFqn,
	string? ImplementationTypeFqn = null,
	string? ServiceLifetime = null);

[Generator(LanguageNames.CSharp)]
internal sealed class EagerRegistryGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(ctx =>
		{
			ctx.AddSource(
				ExcludeFromRegistryAttributeSourceFactory.CreateHintName(),
				ExcludeFromRegistryAttributeSourceFactory.CreateSource());
			ctx.AddSource(
				RegistryEntrySourceFactory.CreateHintName(),
				RegistryEntrySourceFactory.CreateSource());
			ctx.AddSource(
				ServiceLifetimeSourceFactory.CreateHintName(),
				ServiceLifetimeSourceFactory.CreateSource());
			ctx.AddSource(
				ServiceLifetimeAttributesSourceFactory.CreateHintName(),
				ServiceLifetimeAttributesSourceFactory.CreateSource());
			ctx.AddSource(
				OverrideAssemblyNameAttributeSourceFactory.CreateHintName(),
				OverrideAssemblyNameAttributeSourceFactory.CreateSource());
		});
		var metadataProvider = context.MetadataReferencesProvider
			.Select((x, _) => x.GetModules())
			.Collect()
			.Select((x, _) => x
				.SelectMany(y => y)
				.Distinct());
		var extrasProvider = context.CompilationProvider
			.Combine(metadataProvider);
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(Filter, Transform)
			.Where(x => x.Any())
			.Collect()
			.Combine(extrasProvider);
		context.RegisterSourceOutput(provider, Execute);
	}
	
	private static bool Filter(SyntaxNode node, CancellationToken _)
	{
		return node is ClassDeclarationSyntax { Modifiers: var modifiers }
		       // Exclude static or abstract classes
		       && !modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword) || x.IsKind(SyntaxKind.AbstractKeyword))
		       // Exclude nested classes
		       && node.Parent is not ClassDeclarationSyntax
			   // Exclude AutoGenerated classes
			   && !(node.SyntaxTree.FilePath.Contains(".g.") || node.SyntaxTree.FilePath.Contains(".generated."))
		       // With public methods
		       && (node.DescendantNodes().OfType<MethodDeclarationSyntax>()
			       .Any(x => x.Modifiers
				       .Any(y => y.IsKind(SyntaxKind.PublicKeyword)))
		       // Or public properties
			   || node.DescendantNodes().OfType<PropertyDeclarationSyntax>()
			       .Any(x => x.Modifiers
				       .Any(y => y.IsKind(SyntaxKind.PublicKeyword))));
			   
	}
	private static EagerRegistryCandidate[] Transform(GeneratorSyntaxContext context, CancellationToken _)
	{
		var classDeclaration = (ClassDeclarationSyntax)context.Node;
		var classSymbol = ModelExtensions.GetDeclaredSymbol(context.SemanticModel, classDeclaration);
		if (classSymbol is not INamedTypeSymbol @class)
		{
			return [];
		}
		var attributes = @class.GetAttributes();
		if (attributes.Any(x => x.AttributeClass?.Name is "ExcludeFromRegistryAttribute"))
		{
			return [];
		}

		var lifetime = attributes.GetServiceLifetime();
		var @interface = @class.Interfaces.FirstOrDefault();
		var interfaceFqn = @interface?.ToDisplayString();
		var classFqn = @class.ToDisplayString();
		if (interfaceFqn is null)
		{
			return [
				new EagerRegistryCandidate(
				classFqn,
				null,
				lifetime)
			];
		}
		return [
			new EagerRegistryCandidate(
			interfaceFqn, 
			classFqn, 
			lifetime),
			new EagerRegistryCandidate(
				classFqn,
				null,
				lifetime)
		];
	}
	private static void Execute(SourceProductionContext context, (ImmutableArray<EagerRegistryCandidate[]> Candidates, (Compilation Compilation, IEnumerable<ModuleInfo> Modules) Extras) capture)
	{
		var assemblyName = GetAssemblyName(capture.Extras.Compilation.Assembly);
		var assemblyAttributes = capture.Extras.Compilation.Assembly.GetAttributes();
		if (assemblyAttributes.Any(x => x.AttributeClass?.Name is "ExcludeFromRegistryAttribute")) return;
		var assemblyLifetime = assemblyAttributes.GetAssemblyLifetime();
		var assemblyModulesIncludeDiExtensions = capture.Extras.Modules
			.Any(x => x.Name is "Microsoft.Extensions.DependencyInjection.dll");

		if (capture.Candidates.IsEmpty) return;
		var reduced = capture.Candidates
			.SelectMany(x => x)
			.Distinct()
			.Select(c => c with { ServiceLifetime = c.ServiceLifetime ?? assemblyLifetime })
			.ToImmutableArray();

		context.AddSource(
			RegistrySourceFactory.CreateHintName(assemblyName),
			RegistrySourceFactory.CreateSource(assemblyName, reduced));

		if (!assemblyModulesIncludeDiExtensions) return;
		context.AddSource(
			ServiceCollectionExtensionSourceFactory.CreateHintName(),
			ServiceCollectionExtensionSourceFactory.CreateSource(assemblyName));

	}

	private static string GetAssemblyName(IAssemblySymbol compilationAssembly)
	{
		string? overridenName = compilationAssembly
			.GetAttributes()
			.Where(x => x.AttributeClass?.Name is "OverrideAssemblyNameAttribute")
			.Select(x => x.ConstructorArguments.FirstOrDefault().Value?.ToString())
			.FirstOrDefault();
		return overridenName ?? compilationAssembly.Name;
	}
}
