using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using EagerRegistry.SourceFactories;
using EagerRegistry.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EagerRegistry;

internal record EagerRegistryCandidate(
	string ServiceTypeFqn,
	string? ImplementationTypeFqn = null,
	string? ServiceLifetime = null);

[Generator(LanguageNames.CSharp)]
internal sealed class EagerRegistryGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(ctx =>
		{
			ctx.AddSource(
				ExcludeFromRegistryAttributeSourceFactory.CreateHintName(),
				ExcludeFromRegistryAttributeSourceFactory.CreateSource());
			ctx.AddSource(
				RegistryEntrySourceFactory.CreateHintName(),
				RegistryEntrySourceFactory.CreateSource());
			ctx.AddSource(
				ServiceLifetimeSourceFactory.CreateHintName(),
				ServiceLifetimeSourceFactory.CreateSource());
			ctx.AddSource(
				ServiceLifetimeAttributesSourceFactory.CreateHintName(),
				ServiceLifetimeAttributesSourceFactory.CreateSource());
			ctx.AddSource(
				PrioritizeAttributeSourceFactory.CreateHintName(),
				PrioritizeAttributeSourceFactory.CreateSource());
		});
		var compilationProvider = context.CompilationProvider;
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(Filter, Transform)
			.Where(x => x.Any())
			.Collect()
			.Combine(compilationProvider);
		context.RegisterSourceOutput(provider, Execute);
	}
	private static bool Filter(SyntaxNode node, CancellationToken _)
	{
		return node is ClassDeclarationSyntax { Modifiers: var modifiers }
		       // Exclude static or abstract classes
		       && !modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword) || x.IsKind(SyntaxKind.AbstractKeyword))
		       // Exclude nested classes
		       && node.Parent is not ClassDeclarationSyntax
			   // Exclude AutoGenerated classes
			   && !(node.SyntaxTree.FilePath.Contains(".g.") || node.SyntaxTree.FilePath.Contains(".generated."))
		       // With public methods
		       && (node.DescendantNodes().OfType<MethodDeclarationSyntax>()
			       .Any(x => x.Modifiers
				       .Any(y => y.IsKind(SyntaxKind.PublicKeyword)))
		       // Or public properties
			   || node.DescendantNodes().OfType<PropertyDeclarationSyntax>()
			       .Any(x => x.Modifiers
				       .Any(y => y.IsKind(SyntaxKind.PublicKeyword))));
			   
	}
	private static EagerRegistryCandidate[] Transform(GeneratorSyntaxContext context, CancellationToken _)
	{
		var classDeclaration = (ClassDeclarationSyntax)context.Node;
		var classSymbol = ModelExtensions.GetDeclaredSymbol(context.SemanticModel, classDeclaration);
		if (classSymbol is not INamedTypeSymbol @class)
		{
			return [];
		}
		var attributes = @class.GetAttributes();
		if (attributes.Any(x => x.AttributeClass?.Name is "ExcludeFromRegistryAttribute"))
		{
			return [];
		}

		var lifetime = attributes.GetServiceLifetime();
		var @interface = @class.Interfaces.FirstOrDefault();
		var interfaceFqn = @interface?.ToDisplayString();
		var classFqn = @class.ToDisplayString();
		if (interfaceFqn is null)
		{
			return [
				new EagerRegistryCandidate(
				classFqn,
				null,
				lifetime)
			];
		}
		return [
			new EagerRegistryCandidate(
			interfaceFqn, 
			classFqn, 
			lifetime),
			new EagerRegistryCandidate(
				classFqn,
				null,
				lifetime)
		];
	}
	private static void Execute(SourceProductionContext context, (ImmutableArray<EagerRegistryCandidate[]> Candidates, Compilation Compilation) capture)
	{
		var assemblyName = capture.Compilation.AssemblyName ?? string.Empty;
		var assemblyAttributes = capture.Compilation.Assembly.GetAttributes();
		if (assemblyAttributes.Any(x => x.AttributeClass?.Name is "ExcludeFromRegistryAttribute")) return;
		var assemblyLifetime = assemblyAttributes.GetAssemblyLifetime();
		if (capture.Candidates.IsEmpty) return;
		var reduced = capture.Candidates
			.SelectMany(x => x)
			.Distinct()
			.Select(c => c with { ServiceLifetime = c.ServiceLifetime ?? assemblyLifetime })
			.ToImmutableArray();
		context.AddSource(
			RegistrySourceFactory.CreateHintName(assemblyName),
			RegistrySourceFactory.CreateSource(assemblyName, reduced));
	}
}
